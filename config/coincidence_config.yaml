# Dict with uid's as key and a nested dict with configuration variables
general:
  runtime: 600  # desired runtime in seconds
  runevents: &number_of_events 600000000
  number_of_samples: &number_of_samples 1000
  analogue_offset: &analogue_offset 0
  # special settings for RedPitaya
  decimation_index: &decimation 1 # decimation 0:1, i:2^(i+1) # data decimation factor, 0 is 8 ns/sample
  sample_time_ns: &sample_time_ns 256 #  for decimation 4
  invert_channel1: &invert1 0
  invert_channel2: &invert2 0
  trigger_level: &trigger_level 500
  trigger_channel: &trigger_channel '1'
  trigger_direction: &trigger_direction "rising" # or "falling"
  pre_trigger_samples: &pre_trigger_samples 103 # 5%
  filename: &filename spectrum


# dict for coincidence_filter, function filter_waveform
filter:
  clipping_config: 4095 # in adc counts
  trigger_channel: 'ch1'
  peak_config:
    prominence: 200 # has to be positive and higher than avg. noise peaks to not cause havoc!
    distance: 400 # minimal distance between two peaks in number of samples
    width: 10 # in number of samples
  coincidence_config: 
    offset: 0 # in time bins
    width: 100 # in time bins

analyzer:
  pulse_height_integral_config:
    start_stop_mode: ## possible modes by which the baseline is calculated "gradient" "constant" "left_ips_to_peak" "left_ips_to_right_ips" "left_gradient_to_peak"
      ch1: left_gradient_to_peak
      ch2: gradient
    baseline_value:
      ch1: 0
      ch2: 0
    peak_config:
      prominence: 200
      distance: 400
      width: 10
  pulse_height_pavel_config:
    baseline_mode: ## possible modes by which the baseline is calculated "gradient" "constant"
      ch1: gradient
      ch2: gradient
    baseline_value:
      ch1: 0
      ch2: 0
    peak_config:
      prominence: 200
      distance: 400
      width: 10
    

  list_of_channels:
    - 'ch1'
    - 'ch2'


# dict for tar_parquet_source
tar_parquet_source:
  path: "./source/"
  sleeptime: 0.010
  random: False
  number_of_samples: 1000


# dict for RedPitaya redPdaq
redP_to_rb:
  ip_address: 'rp-f0c38f.local'
  eventcount: *number_of_events
  sample_time_ns: *sample_time_ns
  number_of_samples: *number_of_samples
  pre_trigger_samples: *pre_trigger_samples
  trigger_channel: *trigger_channel
  trigger_level: *trigger_level
  trigger_mode: "norm" # or "auto"
  # special settings for RedPitaya
  decimation_index: *decimation
  invert_channel1: *invert1
  invert_channel2: *invert2
  startDAQ: true  # start in DAQ mode
  fallTime: 1
  genRate: 100
  genStart: True
  
# Dict for simul_source.py
simul_source:
  sample_time_ns: *sample_time_ns
  number_of_samples: *number_of_samples
  pre_trigger_samples: *pre_trigger_samples
  analogue_offset: *analogue_offset
  eventcount: *number_of_events
  sleeptime: 0.03
  random: true

# Dict for push_simul
push_simul:
  sample_time_ns: *sample_time_ns
  number_of_samples: *number_of_samples
  pre_trigger_samples: *pre_trigger_samples
  analogue_offset: *analogue_offset
  eventcount: *number_of_events
  sleeptime: 0.03
  random: true

save_to_txt:
  filename: *filename

save_parquet:
  filename: *filename

plot_waveform:
  title: "Coincidence waveform"
  min_sleeptime: 2                  # time to wait between graphics updates
  number_of_samples: *number_of_samples
  sample_time_ns: *sample_time_ns
  analogue_offset: *analogue_offset # analogue offset in V
  pre_trigger_samples: *pre_trigger_samples
  channel_range: 4096                # channel range in mV
  trigger_channel: *trigger_channel  # Channel name in the PicoScope. Valid values are 'A', 'B', 'C' or 'D'  
  trigger_level: *trigger_level  # value in mV, take account of analogue_offset, which is added to input voltage !

plot_histograms:
  title: "on-line histograms"
  # define histograms 
  histograms:  
    #  name        min   max   nbins  ymax   name   lin/log
    ch1_height:   [500., 4096.,   3596, 20., "ph 1A", 0]
    ch2_height:   [500., 4096.,   3596, 20., "ph 1B", 0]

general_plotter:
  filename: *filename
  codefile: "modules/plot_codes.yaml"
  title: "Plotter"